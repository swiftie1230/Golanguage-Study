
# 💭 메서드 

##  1. 메서드 선언

메서드를 선언하려면 리시버를 func 키워드와 함수 이름 사이에 중괄호로 명시해야 한다.        

   ```go
func (r Rabbit) info() int {
	return r.width * r.height
}
   ```    
위 `(r Rabbit)` 부분이 바로 **리시버**이다.   
리시버로 **메서드가 <u>특정 타입에 속한다</u>는 것을 확인**할 수 있으며, **구조체 변수(r)는 <u>해당 메서드에서 매개변수처럼 사용</u>**된다.      
리시버로는 해당 패키지 안에서 type 키워드로 선언된 타입인 **<u>모든 로컬 타입들</u>**이 가능하다. 즉, **<u>패키지 내 선언된 구조체</u>, <u>별칭 타입들</u>**이 리시버가 될 수 있음.    

키워드와 함수명 사이에 리시버 타입과 그 리시버 값을 갖는 변수가 있으면 메서드, 없으면 함수이다.     

<div class="notice--primary" markdown="1">
🌝 <strong><u>여기서 잠깐!</u> : <u>메서드는 어디에 정의하면 좋을까?</u></strong>       

사실 메서드 정의는 같은 패키지 내 어디에도 위치할 수 있다.     
하지만 <u>리시버 타입이 선언된 파일 안에 정의</u>하는 것이 가장 일반적임.                
      
</div>

구조체에서 필드가 해당 구조체에 속하듯이 **메서드 또한 <u>해당 리시버 타입에 속하기에</u>, 구조체의 필드에 접근할 때처럼 <u>점`.`연산자를 사용해 해당 타입에 속한 메서드를 호출</u>**할 수 있다.

### 📌 <u>별칭 리시버 타입</u>

int와 같은 내장 타입들도 별칭 타입을 활용해서 메서드를 가질 수 있다.     

예시를 통해 확인해 보자.   

   ```go
package main

import "fmt"

// 사용자 정의 별칭 타입
type myInt int

func (a myInt) add(b int) int {
	return int(a) + b
}

func main() {
	var a myInt = 10
	fmt.Println( a.add(30) )
	var b int = 20
	fmt.Println(myInt(b).add(50))
}
   ```

이처럼 모든 사용자 정의 타입이 리시버 타입이 될 수 있기 때문에 **기본 내장 타입도 별칭 타입으로 변환**하여 메서드를 선언할 수 있다.


##  2. 메서드는 왜 필요한가?

메서드가 그저 함수의 다른 표현이라고 볼 수도 있지만 이 둘은 **소속**이라는 중요한 차이가 있다.      

**좋은 프로그래밍이라면 결합도<sup>coupling</sup>를 낮추고 응집도<sup>cohesion</sup>를 높여야 한다.** 메서드는 데이터와 관련 기능들을 묶기 때문에 코드 응집도를 높이는 중요한 역할을 한다.    

만약 메서드를 사용하지 않으면 데이터와 기능이 서로 결합되지 않고 이곳저곳에 흩어져 있게 되는데, 여기서 새로운 기능을 추가할 경우, 흩어진 모든 부분을 검토하고 고쳐야 하는 **산탄총 수술 문제**가 발생함. 코드 수정 범위가 늘어나면 관리가 복잡해지므로, 메서드를 이용해서 **흩어진 코드 조각들을 관련된 데이터로 한 곳에 묶어 응집도를 높일 필요**가 있는 것!         

최종적으로 정리해보자면, **메서드는 기능과 데이터를 묶어주는 역할 즉, 응집도를 높이는 역할**을 한다.       

### 📌 <u>객체 지향</u> : <u>절차 중심에서 관계 중심으로 변화</u>

객체 인스턴스들이 서로 유기적으로 소통하고 관계 맺게 됨에 따라 <u>절차</u>보다는 <u>**객체 간 관계 중심**</u>으로 **프로그래밍 패러다임이 변화**하였다.       
이것을 **객체지향 프로그래밍<sup>object oriented programming</sup>**, 줄여서 **OOP**라고 부른다.   
 

## 3. 포인터 메서드 vs 값 타입 메서드

포인터 메서드를 호출하면 포인터가 가리키고 있는 메모리의 주솟값이 복사되는 반면, 값 타입 메서드를 호출하면 리시버 타입의 모든 값이 복사된다.   

**포인터 메서드는 메서드 내부에서 리시버의 값을 변경시킬 수 있다. 그러나 값 타입 메서드는 호출하는 쪽과 메서드 내부의 값은 별도 인스턴스로 독립되기 때문에 메서드 내부에서 리시버 값을 변경시킬 수 없다.**    

정리해보면, **포인터 메서드는 인스턴스 중심이고 값 타입 메서드는 값 중심!**     
