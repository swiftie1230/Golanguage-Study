# 19. 메서드

## 19. 메서드 선언

메서드를 선언하려면 리시버를 func 키워드와 함수 이름 사이에 중괄호로 명시해야 한다.

    func (r Rabbit) info() int {
        return r.width * r.height
    }


`(r Rabbit)` : 리시버

`info()` : 메서드명

_리시버 덕분에 info() 메서드가 Rabbit 타입에 속한다는 것을 알게 되었다!_

리시버로는 모든 로컬 타입들이 가능한데, 로컬 타입이란 **해당 패키지 안에서 type 키워드로 선언된 타입들을 말한다.**

그래서 패키지 내 선언된 구조체, 별칭 다입들이 리시버가 될 수 있다.

❗️ 일반 함수와 메서드는 호출 방법이 다르다.

구조체에서 필드가 해당 구조체에 속하듯이 메서드는 해당 리시버 타입에 속한다.

구조체의 필드에 접근할 때 처럼 점 . 연산자를 이용해 해당 타입에 속한 메서드를 호출할 수 있다.

    a.withdraw2(30)

---

## 19-1. 별칭 리시버 타입

모든 로컬 타입이 리시버 타입으로 가능하기 때문에 별칭 타입도 리시버가 될 수 있고 메서드를 가질 수 있다.

    package main

    import "fmt"

    type myInt int                      // 사용자 정의 별칭 타입

    func(a myInt) add(b int) int {      // myInt 별칭 타입을 리시버로 갖는 메서드
        return int(a) + b
    }

    func main() {
        var a myInt = 10                // myInt 타입 변수
        fmt.Println( a. add(30) )       // myInt 타입의 add() 메서드 호출
        var b int = 20
        fmt.Println(myInt(b).add(50))   // int 타입을 타입 변환
    }

---

## 19-2. 메서드는 왜 필요한가?

왜 복잡하게 메서드라는 걸 만들까?

그저 함수의 다른 표현이라고 볼 수도 있지만 이 둘은 중요한 차이가 있는데 그건 `소속` 이다.

일반 함수는 어디에도 속하지 않지만 메서드는 리시버에 속한다.

_Student 구조체가 있다고 가정할 때, Student 구조체의 필드로 이름, 반, 번호, 성적등의 데이터가 있을텐데, 메서드는 성적입력, 반 배정 등의 Student 구조체의 기능을 나타낸다._

🔅 좋은 프로그래밍이라면 결합도를 낮추고 응집도를 높여야 한다. 메서드는 데이터와 관련 기능을 묶기 때문에 코드 응집도를 높이는 중요한 역할을 한다.

**즉!** 메서드는 바로 기능과 데이터를 묶어주는 역할, 즉 응집도를 높이는 역할을 한다.

---

메서드라는 기능이 생기고 메서드를 통해 데이터와 기능을 묶을 수 있게 됨으로써 데이터와 기능이 묶인 단일 객체로써 동작하게 됐는데

`객체`란 데이터와 기능을 갖는 타입을 말하고 이 타입의 인스턴서를 `객체 인스턴스`라고 말한다.

---

## 19-3. 포인터 메서드 vs 값 타입 메서드

리시버를 값 타입과 포인터로 정의할 수 있다.

1. 포인터 메서드

        func(a1. *accout) withdrawPointer(amount int) {
            a1.balance -= amount
        }

2. 값 타입 메서드

        func (a2 account)withdrawValue(amount int) {
            a2.balance -= amount
        }

