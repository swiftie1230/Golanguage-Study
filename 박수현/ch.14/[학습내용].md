# 포인터란?

포인터는 메모리 주소를 값으로 갖는 타입이다.

메모리 주솟값을 변숫값으로 가질 수 있는 변수를 포인터 변수라고 한다.

    p = &a

_포인터 변수 p에 a의 주소를 대입하는 구문이다._

_포인터 변수 p가 변수 a를 가리킨다._

**메모리 주소를 값으로 가져 메모리 공간을 가리키는 타입을 포인터라고 한다!!**

---

## 포인터 변수 선언

포인터 변수는 가리키는 데이터 타입 앞에 *을 붙여서 선언한다.

    var p *int

_p는 int 타입 데이터의 메모리 주소를 가리키는 포인터 변수다._

**포인터는 메모리 주소를 값으로 갖는다!**

    var a int
    var p *int
    p = &a      // a의 메모리 주소를 p에 대입한다.

포인터 변수 앞에 *을 붙이면 그 포인터 변수가 가리키는 메모리 공간에 접근할 수 있다.

    *p = 20

---

## 예제

    package main

    import "fmt"

    func main() {
        var a int = 500
        var p *int

        p = &a

        fmt.Printf("p의 값 : %p\n", p)
        fmt.Printf("p가 가리키는 메모리의 값: %d\n", *p)

        *p = 100
        fmt.Printf("a의 값: %d\n", a)
    }

---

## 포인터 변숫값 비교하기

== 연산을 사용해 포인터가 같은 메모리 공간을 가리키는지 확인할 수 있다.

    package main

    import "fmt"

    func main() {
        var a int = 10
        var b int = 20

        var p1 *int = &a
        var p2 *int = &b
        var p3 *int = &b

        fmt.Printf("p1 == p2 : %v\n", p1 == p2)
        fmt.Printf("p2 == p3 : %v\n", p2 == p3)
    }

## 포인터의 기본값 nil

포인터 변숫값을 초기화하지 않으면 기본값은 nil이다. 이 값은 0이지만 정확한 의미는 유효하지 않는 메모리 주솟값 즉, 어떤 메모리 공간도 가리키고 있지 않음을 나타낸다.

    var p *int 
    if p != nil {
        // p가 nil이 아니라는 얘기는 p가 유효한 메모리 주소를 가리킨다는 뜻이다.
    }

## 포인터는 왜 쓸까?

변수 대입이나 함수 인수 전달은 항상 값을 복사하기 때문에 많은 메모리 공간을 사용하는 문제와, 큰 메모리 공간을 복사할 때 발생하는 성능 문제를 안고 있다.

하지만 포인터를 사용하면 더 효율적으로 데이터를 조작할 수 있다.

_직접 예제 실습해보기!!_

---

## Data 구조체를 생성해 포인터 변수 초기화하기

* 기존방식

        var data Data           // Data타입 구조체 변수 data를 선언합니다.

        var p *Data = &data     // data 변수의 주소를 반환합니다.

* 구조체를 생성해 초기화 하는 방식

        var p *Data = &Data{}       // Data 타입 구조체 변수 p를 선언하고, Data 구조체를 만들어 주소를 반환한다.


_메모리에 실제로 있는 구조체 데이터의 실체를 가리키게 되므로 포인터 변수 p만 가지고도 구조체의 필드값에 접근하고 변경할 수 있다._

---

## 인스턴스

메모리에 할당된 데이터의 실체 : `인스턴스`

    var data Data

_이렇게 할당된 메모리 공간의 실체를 인스턴스라고 부른다!_


* Data 타입 포인터 변수를 선언하고 data 변수의 주소를 값으로 대입

    var data Data
    var p *Data = &data

Data 타입 포인터 변수 p를 선언하고 data의 주소를 대입 (_포인터 변수 p는 data를 가리킨다고 말한다._)

p가 생성될 때 새로운 Data 인스턴스가 만들어진게 아니라 기존에 있던 data 인스턴스를 가리킨 것. 즉 만들어진 총 Data 인스턴스 개수는 1개이다.


### 인스턴스를 별도로 생성하지 않고, 곧바로 인스턴스를 생성해 그 주소를 포인터 변수에 초깃값으로 대입하는 코드

    var p *Data = &Data{}

_Data 인스턴스를 만들고 그 메모리 주소를 포인터 변수 p가 가리킨다._ (인스턴스는 하나)

**!! 포인터 변수가 아무리 많아도 인스턴스가 추가로 생성되는 것은 아님 !!**

---

## 인스턴스는 데이터의 실체

인스턴스는 메모리에 존재하는 `데이터의 실체`다.

구조체 포인터를 함수 매개변수로 받는다 == 구조체 인스턴스로 입력을 받겠다.

### new() 내장 함수

new 내장 함수를 이용하면 더 간단히 표현 가능하다.

    p1 := &Data{}           // &을 사용하는 초기화
    var p2 = new(Data)      // new()를 사용하는 초기화

_new 내장함수는 인수로 타입을 받아 타입을 메모리에 할당하고 기본값으로 채워 그 주소를 반환한다._

new를 이용해서 내부 필드값을 원하는 값으로 초기화 할 수는 없음

---

### 인스턴스는 언제 사라지나?

메모리에 데이터가 할당만 되고 사라지지 않는다면 프로그램은 금세 메모리가 고갈되어 프로그램이 비정상 종료가 될 것 이다.

그래서 쓸모없는 데이터를 메모리에서 해제하는 기능이 필요!

`아무도 찾지 않는 데이터는 쓸모없는 데이터이다.`

    func Testfunc() {
        u := &User{}        // u포인터 변수를 선언하고 인스턴스를 생성한다.
        u.Age = 30
        fmt.Println(u)      
    }                       // 내부 변수 u는 사라지면서 더불어 인스턴스도 사라진다.


---

## 스택 메모리와 힙 메모리

대부분 프로그래밍 언어는 메모리를 할당할 때 스택 메모리 영역 또는 힙 메모리 영역을 사용한다.

이론상 스택 메모리 영역이 힙 메모리 영역보다 훨씬 효줄적이지만, 스택 메모리는 함수 내부에서만 사용 가능

그래서 함수 외부로 공개되는 메모리 공간은 힙 메모리 영역에서 할당한다. (c, c++ == malloc())

_GO언어는 탈출검사를 해서 어느 메모리에 할당할지를 결정한다._


